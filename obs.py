import tensorflow as tf
from wavefunc import Wavefunction


inf = 100 # in case we need log 0 = -inf

def make_action_func(func):
    def action_func(wavefunc):
        def log_psi_func(x):
            return func(wavefunc, x)
        return Wavefunction(log_psi_func)
    return action_func

class Observable():
    """Class for quantum observables. Observables are maps from Wavefunction to Wavefunction, i.e.,
    |psi> -> O |psi>. Must implement the `action' method.
    """

    def __init__(self, action_func=None):
        self.action_func = action_func

    def action(self, wavefunc):
        if not isinstance(wavefunc, Wavefunction):
            raise TypeError("argument must be wavefunction")
        if self.action_func is None:
            raise NotImplementedError
        res = self.action_func(wavefunc)
        assert isinstance(res, Wavefunction), "return value must be wavefunction"
        return res

    def __mul__(self, other):
        if isinstance(other, Observable):
            def action_func(wavefunc):
                return self.action(other.action(wavefunc))
            return Observable(action_func)
        if isinstance(other, (float, int, complex)):
            @make_action_func
            def action_func(wavefunc, x):
                if other == 0:
                    return tf.constant(-inf, dtype=tf.complex64)
                return tf.math.log(tf.constant(other, dtype=tf.complex64)) + self.action(wavefunc).log_psi(x)
            return Observable(action_func)
        return NotImplemented

    def __rmul__(self, other):
        if isinstance(other, (float, int, complex)):
            return self * other
        return NotImplemented

    def __add__(self, other):
        if isinstance(other, Observable):
            @make_action_func
            def action_func(wavefunc, x):
                s, t = self.action(wavefunc).log_psi(x), other.action(wavefunc).log_psi(x)
                m = tf.stop_gradient(tf.cast(tf.math.maximum(-float(inf), tf.math.maximum(tf.math.real(s), tf.math.real(t))), tf.complex64))
                return tf.math.log(tf.exp(s - m) + tf.exp(t - m)) + m
            return Observable(action_func)
        return NotImplemented

    def __sub__(self, other):
        return self + other * (-1)

    def __neg__(self):
        return self * (-1)

    def evaluate(self, wavefunc, sampler, batch_size=100, normalized=True):
        # evaluate the expectation value on wavefunc from samples generated by the sampler
        # the wavefunc could be unnormalized; if normalized is True, normalization is done by evaluating expectation of identity
        # if normalized is True, this is a biased estimator (b.c. the ratio of the averages is not the average of the ratios)
        # so the result could be unreliable when variance is large
        vectors, log_prob = sampler.sample(batch_size, with_log_prob=True)
        density = self.action(wavefunc).log_psi(vectors) + tf.math.conj(wavefunc.log_psi(vectors))
        one = wavefunc.log_psi(vectors) + tf.math.conj(wavefunc.log_psi(vectors))
        log_prob = tf.stop_gradient(tf.cast(log_prob, tf.complex64))
        if normalized:
            return tf.math.reduce_mean(tf.math.exp(density - log_prob)) / tf.math.reduce_mean(tf.math.exp(one - log_prob))
        else:
            return tf.math.reduce_mean(tf.math.exp(density - log_prob))

    def gauge_evaluate(self, wavefunc, sampler, algebra, group, batch_size=100, normalized=True):
        # evaluate the expectation value on wavefunc averaged over random group actions
        vectors, log_prob = sampler.sample(batch_size, with_log_prob=True)
        matrices = algebra.vector_to_matrix(vectors)
        g = group.random_element(batch_size)
        _vectors = tf.math.real(algebra.matrix_to_vector(group.action(g, matrices)))
        density = self.action(wavefunc).log_psi(_vectors) + tf.math.conj(wavefunc.log_psi(vectors))
        one = wavefunc.log_psi(_vectors) + tf.math.conj(wavefunc.log_psi(vectors))
        log_prob = tf.stop_gradient(tf.cast(log_prob, tf.complex64))
        if normalized:
            return tf.math.reduce_mean(tf.math.exp(density - log_prob)) / tf.math.reduce_mean(tf.math.exp(one - log_prob))
        else:
            return tf.math.reduce_mean(tf.math.exp(density - log_prob))


def complex_grad(tensor, var):
    return tf.complex(tf.gradients(tf.math.real(tensor), var)[0], tf.gradients(tf.math.imag(tensor), var)[0])

def matrix_quadratic_potential(algebra):
    """sum_i tr X_i X_i"""
    @make_action_func
    def action_func(wavefunc, x):
        matrices = algebra.vector_to_matrix(x)[:, :algebra.num_b, :, :]
        return tf.math.log(tf.einsum("birs,bisr->b", matrices, matrices)) + wavefunc.log_psi(x)
    return Observable(action_func)

def fermion_number(algebra):
    @make_action_func
    def action_func(wavefunc, x):
        return tf.math.log(tf.cast(tf.math.reduce_sum(x[:, algebra.dim_b:], axis=-1), tf.complex64)) + wavefunc.log_psi(x)
    return Observable(action_func)

def matrix_commutator_potential(algebra):
    """sum_ij tr [X_i, X_j]^2"""
    @make_action_func
    def action_func(wavefunc, x):
        matrices = algebra.vector_to_matrix(x)[:, :algebra.num_b, :, :]
        commutator = tf.einsum("birs,bjst->bijrt", matrices, matrices) - tf.einsum("bist,bjrs->bijrt", matrices, matrices)
        commutator_square = tf.einsum("bijrs,bijsr->b", commutator, commutator)
        return tf.math.log(commutator_square) + wavefunc.log_psi(x)
    return Observable(action_func)

def create_fermion(x, mode):
    """Return the log sign and the resulting fermion state after creating a mode on state x.
    x is a batch of binary vectors, which are fermion number basis states, and mode has the same shape as x,
    but each vector in mode contains only one 1, which is the mode to create.
    """
    sign = 1 - 2 * (tf.math.reduce_sum((1 - tf.math.cumsum(mode, axis=-1, exclusive=False)) * x, axis=-1) % 2)
    coef = sign * (1 - tf.math.reduce_sum(x * mode, axis=-1))
    coef = tf.cast(coef, tf.complex64) + 1e-20 # a small number for some numerical stability
    new_x = tf.math.minimum(x + mode, 1)
    return tf.stop_gradient(tf.math.log(coef)), tf.stop_gradient(new_x)

def annihilate_fermion(x, mode):
    """Return the log sign and the resulting fermion state after annihilating a mode on state x.
    x is a batch of binary vectors, which are fermion number basis states, and mode has the same shape as x,
    but each vector in mode contains only one 1, which is the mode to destroy.
    """
    sign = 1 - 2 * (tf.math.reduce_sum((1 - tf.math.cumsum(mode, axis=-1, exclusive=False)) * x, axis=-1) % 2)
    coef = sign * tf.math.reduce_sum(x * mode, axis=-1)
    coef = tf.cast(coef, tf.complex64) + 1e-20 # a small number for some numerical stability
    new_x = tf.math.maximum(x - mode, 0)
    return tf.stop_gradient(tf.math.log(coef)), tf.stop_gradient(new_x)

def matrix_fermionic_bilinear(algebra, bilinear_func, adjoint_a=True, adjoint_b=False):
    """Return the observable V(Psi^dagger, Psi) for bilinear V; the leftmost Psi acts last.
    If adjoint_a is False, the first Psi is not daggered; if adjoint_b is True, the second Psi is daggered.
    !! Value of this observable is not exact and is estimated from random samples of fermion terms !!
    """
    @make_action_func
    def action_func(wavefunc, x):
        dim_b, dim_f = algebra.dim_b, algebra.dim_f
        batch_size, _ = x.shape.as_list()
        # randomly take a term in the sum of bilinears
        aux = tf.random.uniform(shape=(batch_size, 2), maxval=dim_f, dtype=tf.int32)
        fermions = tf.one_hot(aux, dim_f)
        def to_matrix(fermions):
            padded = tf.concat([tf.zeros((batch_size, dim_b)), fermions], axis=-1)
            return algebra.vector_to_matrix(padded)
        # computes potential V
        bosonic_matrices = algebra.vector_to_matrix(x)[:, :algebra.num_b, :, :]
        matrices1, matrices2 = to_matrix(fermions[:, 0, :]), to_matrix(fermions[:, 1, :])
        log_coef = tf.math.log(dim_f * dim_f * bilinear_func(matrices1, matrices2, bosonic_matrices) + 1e-10)
        # acts with Psi^dagger and Psi
        x_bosonic, x_fermionic = x[:, :dim_b], x[:, dim_b:]
        c1, x_fermionic = annihilate_fermion(x_fermionic, fermions[:, 0, :]) if adjoint_a else create_fermion(x_fermionic, fermions[:, 0, :])
        c2, x_fermionic = annihilate_fermion(x_fermionic, fermions[:, 1, :]) if adjoint_b else create_fermion(x_fermionic, fermions[:, 1, :])
        log_coef = log_coef + c1 + c2
        # no change for the bosonic part
        new_x = tf.concat([x_bosonic, x_fermionic], axis=-1)
        return log_coef + wavefunc.log_psi(new_x)
    return Observable(action_func)

def group_action(algebra, group, dg, bosonic_only=False):
    # operator dg (element of Lie algebra of group) = (tr (dg X) P - i tr (dg Psi)^dagger Psi)
    obs = None
    # bosonic part of the group action
    if algebra.dim_b > 0:
        @make_action_func
        def bosonic_action_func(wavefunc, x):
            batch_size, _ = x.shape.as_list()
            matrices = algebra.vector_to_matrix(x)
            # no change in fermionic matrices
            dmatrices = tf.concat([
                group.infinitesimal_action(dg, matrices)[:, :algebra.num_b, :, :],
                tf.zeros_like(matrices[:, algebra.num_b:, :, :])], axis=1)
            dvectors = tf.cast(algebra.matrix_to_vector(dmatrices), tf.complex64)
            grad = tf.math.reduce_sum(complex_grad(wavefunc.log_psi(x), x) * dvectors, axis=-1)
            return tf.math.log(-1j * grad) + wavefunc.log_psi(x)
        obs = Observable(bosonic_action_func)
    # fermionic part of the group action
    dim_f = algebra.dim_f
    batch_size, _ = dg.shape.as_list()
    if dim_f > 0 and not bosonic_only:
        def bilinear_func(matrices1, matrices2, bosonic_matrices):
            return 1j * tf.math.reduce_sum(tf.math.conj(matrices1) * group.infinitesimal_action(dg, matrices2), [-1, -2, -3])
        if obs is None:
            obs = matrix_fermionic_bilinear(algebra, bilinear_func)
        else:
            obs = obs + matrix_fermionic_bilinear(algebra, bilinear_func)
    return obs 

def casimir(algebra, group, bosonic_only=False):
    # casimir is sum dg^2 where dg runs over some orthonormal basis of the Lie algebra
    @make_action_func
    def action_func(wavefunc, x):
        batch_size, _ = x.shape.as_list()
        op = group_action(algebra, group, group.random_algebra_element(batch_size), bosonic_only)
        return op.action(op.action(wavefunc)).log_psi(x)
    return Observable(action_func)

def matrix_kinetic_energy(algebra):
    # kinetic term is the casimir of translations
    return casimir(algebra, algebra, True)

def identity_operator():
    def action_func(wavefunc):
        return wavefunc
    return Observable(action_func)

def minimal_BMN_energy(algebra, g, mu, bosonic_only=False):
    # the hamiltonian is tr 0.5 (P1^2 + P2^2) - 0.5 g^2 [X1, X2]^2 + 0.5 g xi [-X1 - i X2, xi] + 0.5 g xi^dagger [-X1 + i X2, xi^dagger] + 1.5 mu xi^dagger xi
    # + 0.5 mu^2 (X1^2 + X2^2) - (N^2 - 1) mu
    # two bosonic, one complex fermionic SU(N) matrices
    N = algebra.alg.N
    dim_f = algebra.dim_f
    def yukawa_bilinear_func1(matrices1, matrices2, bosonic_matrices):
        X1, X2 = bosonic_matrices[:, 0, :, :], bosonic_matrices[:, 1, :, :]
        xi1, xi2 = matrices1[:, 2, :, :], matrices2[:, 2, :, :]
        commutator = lambda x, y: tf.linalg.matmul(x, y) - tf.linalg.matmul(y, x)
        return tf.linalg.trace(tf.linalg.matmul(xi1, commutator(-X1 - 1j * X2, xi2)))
    def yukawa_bilinear_func2(matrices1, matrices2, bosonic_matrices):
        X1, X2 = bosonic_matrices[:, 0, :, :], bosonic_matrices[:, 1, :, :]
        xi1, xi2 = tf.linalg.adjoint(matrices1[:, 2, :, :]), tf.linalg.adjoint(matrices2[:, 2, :, :])
        commutator = lambda x, y: tf.linalg.matmul(x, y) - tf.linalg.matmul(y, x)
        return tf.linalg.trace(tf.linalg.matmul(xi1, commutator(-X1 + 1j * X2, xi2)))
    bosonic_energy = 0.5 * matrix_kinetic_energy(algebra) + 0.5 * mu * mu * matrix_quadratic_potential(algebra) - 0.25 * g * g * matrix_commutator_potential(algebra)
    if bosonic_only:
        return bosonic_energy
    fermionic_energy = 0.5 * g * matrix_fermionic_bilinear(algebra, yukawa_bilinear_func1, adjoint_a=False) \
                    + 0.5 * g * matrix_fermionic_bilinear(algebra, yukawa_bilinear_func2, adjoint_b=True) \
                    + 1.5 * mu * fermion_number(algebra)
    return bosonic_energy + fermionic_energy - (N * N - 1) * mu * identity_operator()

